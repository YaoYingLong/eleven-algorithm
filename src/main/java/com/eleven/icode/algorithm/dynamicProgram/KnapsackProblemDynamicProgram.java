package com.eleven.icode.algorithm.dynamicProgram;

/**
 * 把5kg的袋子，拆分成1kg，1kg这样子计算，里面的表格就表示当前重量下能装的最多的钱。表格的数列就表示是要装的物品
 * ---------   1kg	2kg	3kg	4kg	5kg
 * 加入物品1	6	6	6	6	6
 * 加入物品2	6	10	10+6=16	10+6=16	16
 * 加入物品3	6	10	16	16	18
 * <p>
 * 加入物品2时，袋子当前为1kg 的容量时，发现物品2装不进去。那应该取多少呢？是不是只要取物品进来时1kg最大钱？当袋子为2kg时
 * 发现物品2可以装下去，此时可以得到10块钱，之前物品1进来时2kg最大是6，那肯定要选择大的这个10，而不是6，此时袋子还剩0kg可以装。
 * <p>
 * 袋子为3kg时，还是可以装下这个物品2，得到10块，袋子还剩下1kg，10+1kg能装的东西。
 * 物品3来了，袋子为4kg时，物品3可以装进来，得到12块钱，袋子还剩0kg。但不装物品3 还能得到16呢
 * 物品3来了，袋子为5kg时，物品3可以装进来，得到12块钱，袋子还剩1kg。那么装了物品3就能得到12+6=18块钱
 * 发现不装物品3 能得到16，比18小，所以决定装。
 * <p>
 * 上面这一个递推过程总结起来就是一个东西------状态转移方程：
 * 能装时，每次和上面的比较，大我就装，否则就不装。
 * Max(money[i]+res[i-1][w-weight[i]],res[i-1][w]);
 * <p>
 * money[i]+res[i-1][w-weight[i]]：装这个物品
 * w-weight[i]：表示装完还剩下的空间
 * res[i-1][w-weight[i]]：表示装完后剩下的空间还能装的最大值，取上一次的结果。
 * Res[i-1][w]：表示不装这个物品的值
 * <p>
 * 和遍历的比较及优化：
 * 遍历每次在物品加进来时都会保存选择与不选择两种状态，这样下去越到后面状态保存就越多其实就是2^n次，
 * 因为每个物品都有选与不选两种情况。而动态规划是每次都会把当前情况下的最优解计算出来，层层递推，
 * 下一层的最优解都是基于它上一次结果存下来的，所以最后一个结果就一定是最优解。
 * 其实也是把问题都分解成了一个子问题，然后通过子问题去求解全局最优解。
 */
public class KnapsackProblemDynamicProgram {
    /**
     * 50kg的袋子，且物品不能重复，求最大价值
     * 物品：
     * 钱：60  100  120
     * Kg：10  20   40
     */
    public static void main(String[] args) {
        int[] value = new int[]{60, 100, 120};
        int[] weigth = new int[]{10, 20, 40};    // 购物车那个问题 只需要一个价值就行了，重量都都没有。

        int w = 50;    // 背包总共能装50KG重量的物品
        int n = 3;     // 总共物品数量
        int dp[][] = new int[n + 1][w + 1];    // n表示是物品，w表示重量,初始化全是0

        for (int i = 1; i <= n; i++) {    // 每次加的物品
            for (int cw = 1; cw <= w; cw++) {    // 分割的背包
                if (weigth[i - 1] <= cw) {    // 表示这个物品可以装进去
                    dp[i][cw] = Math.max(
                            value[i - 1] + dp[i - 1][cw - weigth[i - 1]],
                            dp[i - 1][cw]
                    );
                } else {
                    dp[i][cw] = dp[i - 1][cw];    //不能装
                }
            }
        }
        System.out.println(dp[n][w]);
    }
}
